<!DOCTYPE html>
<html>
<head>
    <title>3D Shooting Game - Wireframe Style with Level Up Sound</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; }
        #restartBtn { 
            position: absolute; 
            top: 10px; 
            right: 10px; 
            padding: 5px 10px; 
            background: #4444ff; 
            color: white; 
            border: none; 
            cursor: pointer; 
            font-family: Arial;
        }
        #restartBtn:hover { background: #0000cc; }
        canvas { display: block; }
        #mobileMessage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-family: Arial;
            font-size: 20px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="info">Score: 0 | Level: 1 | Time: 30</div>
    <button id="restartBtn">Restart Game</button>
    <div id="mobileMessage" style="display: none;">
        This game is best experienced on desktop.<br>Please open it on a desktop browser for optimal performance.
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <script>
        // Check if on mobile device
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const mobileMessage = document.getElementById('mobileMessage');

        if (isMobile) {
            mobileMessage.style.display = 'flex';
            throw new Error("Mobile device detected - game stopped");
        }

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Static lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Black background
        scene.background = new THREE.Color(0x000000);

        // Game variables
        let score = 0;
        let level = 1;
        let targets = [];
        let particles = [];
        let levelTimer = 30;
        let gameActive = true;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const infoElement = document.getElementById('info');
        const restartButton = document.getElementById('restartBtn');

        // Audio setup
        const listener = new THREE.AudioListener();
        camera.add(listener);
        const audioLoader = new THREE.AudioLoader();
        
        const shootSound = new THREE.Audio(listener);
        const explosionSound = new THREE.Audio(listener);
        const levelUpSound = new THREE.Audio(listener);
        const backgroundMusic = new THREE.Audio(listener);

        // Load sounds with callbacks to ensure they're ready
        audioLoader.load('zapi.ogg', buffer => {
            shootSound.setBuffer(buffer);
            shootSound.setVolume(0.5);
        });
        audioLoader.load('boom.wav', buffer => {
            explosionSound.setBuffer(buffer);
            explosionSound.setVolume(0.5);
        });
        audioLoader.load('power-up.wav', buffer => {
            levelUpSound.setBuffer(buffer);
            levelUpSound.setVolume(0.5);
        });
        audioLoader.load('bg.wav', buffer => {
            backgroundMusic.setBuffer(buffer);
            backgroundMusic.setLoop(true);
            backgroundMusic.setVolume(0.5);
            backgroundMusic.play();
        });

        // Target creation (wireframe)
        function createTarget() {
            const baseGeometry = new THREE.BoxGeometry(3, 3, 3);
            const sphereGeometry = new THREE.SphereGeometry(2, 32, 32);
            const tetraGeometry = new THREE.TetrahedronGeometry(2.5);

            const geometry = new THREE.BufferGeometry().copy(baseGeometry);
            geometry.morphAttributes.position = [
                baseGeometry.attributes.position.clone(),
                sphereGeometry.attributes.position.clone(),
                tetraGeometry.attributes.position.clone()
            ];

            const material = new THREE.MeshBasicMaterial({
                color: Math.random() * 0xffffff,
                wireframe: true,
                wireframeLinewidth: 2
            });

            const target = new THREE.Mesh(geometry, material);
            target.scale.set(2, 2, 2);
            target.castShadow = true;
            target.receiveShadow = true;
            
            target.position.set(
                (Math.random() - 0.5) * 30,
                (Math.random() - 0.5) * 30,
                -15 - Math.random() * 25
            );
            
            target.userData.morphProgress = 0;
            target.userData.morphSpeed = 0.01 + Math.random() * 0.02;
            
            scene.add(target);
            targets.push(target);
        }

        // Explosion (wireframe particles)
        function createExplosion(position, scale = 1) {
            const particleCount = 40 * scale;
            const particleGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            
            for (let i = 0; i < particleCount; i++) {
                const material = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color().setHSL(Math.random(), 1, 0.5),
                    wireframe: true
                });
                const particle = new THREE.Mesh(particleGeometry, material);
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 4 * scale,
                    (Math.random() - 0.5) * 4 * scale,
                    (Math.random() - 0.5) * 4 * scale
                );
                particle.life = 1.0;
                
                scene.add(particle);
                particles.push(particle);
            }
            explosionSound.play();
        }

        // Unified input handler
        function handleInput(x, y) {
            if (!gameActive) return;

            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(targets);
            if (intersects.length > 0) {
                shootSound.play();
                handleHit(intersects[0]);
            }
        }

        function onMouseClick(event) {
            event.preventDefault();
            handleInput(event.clientX, event.clientY);
        }

        function onTouchStart(event) {
            event.preventDefault();
            const touch = event.touches[0];
            handleInput(touch.clientX, touch.clientY);
        }

        function handleHit(intersect) {
            const target = intersect.object;
            createExplosion(target.position);
            scene.remove(target);
            targets = targets.filter(t => t !== target);
            score += 10;
            updateInfo();
        }

        function updateInfo() {
            infoElement.textContent = `Score: ${score} | Level: ${level} | Time: ${Math.ceil(levelTimer)}`;
        }

        // Initialize level
        function initLevel() {
            if (!gameActive) return;
            
            targets.forEach(target => scene.remove(target));
            particles.forEach(particle => scene.remove(particle));
            targets = [];
            particles = [];

            const targetCount = level * 3;
            for (let i = 0; i < targetCount; i++) {
                createTarget();
            }
            levelTimer = 30;
            updateInfo();
        }

        // Restart game
        function restartGame() {
            if (!gameActive) return;
            
            score = 0;
            level = 1;
            targets.forEach(target => scene.remove(target));
            particles.forEach(particle => scene.remove(particle));
            targets = [];
            particles = [];

            initLevel();
        }

        // Animation loop with level-up sound
        function animate() {
            if (!gameActive) return;

            requestAnimationFrame(animate);

            levelTimer -= 1/60;
            if (levelTimer <= 0) {
                gameActive = false;
                backgroundMusic.stop();
                document.body.innerHTML = '<h1 style="color: black; text-align: center; margin-top: 20%; font-family: Arial;">Time Up!<br>Final Score: ' + score + '</h1>';
                window.removeEventListener('click', onMouseClick);
                window.removeEventListener('touchstart', onTouchStart);
                window.removeEventListener('resize', resizeHandler);
                return;
            }

            particles.forEach((particle, index) => {
                particle.position.add(particle.velocity);
                particle.life -= 0.02;
                particle.scale.setScalar(particle.life);
                if (particle.life <= 0) {
                    scene.remove(particle);
                    particles.splice(index, 1);
                }
            });

            targets.forEach(target => {
                target.rotation.x += 0.01;
                target.rotation.y += 0.01;
                
                target.userData.morphProgress += target.userData.morphSpeed;
                const t = (Math.sin(target.userData.morphProgress) + 1) / 2;
                
                target.morphTargetInfluences[0] = 1 - t;
                target.morphTargetInfluences[1] = t * (1 - t);
                target.morphTargetInfluences[2] = t;
                
                if (target.userData.morphProgress > Math.PI * 2) {
                    target.userData.morphProgress = 0;
                }
            });

            if (targets.length === 0) {
                if (levelUpSound.isPlaying) {
                    levelUpSound.stop(); // Stop if already playing to avoid overlap
                }
                levelUpSound.play(); // Play level-up sound
                level++;
                initLevel();
            }

            updateInfo();
            renderer.render(scene, camera);
        }

        // Setup
        camera.position.z = 10;
        initLevel();
        animate();

        // Event listeners
        window.addEventListener('click', onMouseClick);
        window.addEventListener('touchstart', onTouchStart, { passive: false });
        restartButton.addEventListener('click', restartGame);
        
        function resizeHandler() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', resizeHandler);
    </script>
</body>
</html>